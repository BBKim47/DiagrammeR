<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="DiagrammeR, an R package that allows you to create flowcharts, diagrams, and graphs with Markdown-like text.">
        <meta name="keywords" content="R, JavaScript, graphviz, mermaid">
        <meta name="author" content="Richard Iannone and DiagrammeR contributors">

        <title>
        DiagrammeR - Documentation
        </title>

        <link href="css/bootstrap.min.css" rel="stylesheet">
        <link href="css/docs.min.css" rel="stylesheet">

        <script src="js/ie-emulation-modes-warning.js"></script>

        <link rel="apple-touch-icon" href="/apple-touch-icon.png">
        <link rel="icon" href="/favicon.ico">
    </head>

<body>
    <a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

    <!-- Docs master nav -->
    <header class="navbar navbar-static-top bs-docs-nav" id="top" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a href="index.html" class="navbar-brand">DiagrammeR</a>
            </div>
            <nav class="collapse navbar-collapse bs-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li>
                      <a href="docs.html">Getting started</a>
                    </li>
                    <li>
                      <a href="io.html">I/O</a>
                    </li>
                    <li>
                      <a href="graphviz.html">Graphviz</a>
                    </li>
                    <li>
                      <a href="mermaid.html">Mermaid</a>
                    </li>
                    <li class="active">
                      <a href="graphs.html">Building Graphs</a>
                    </li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://github.com/rich-iannone/DiagrammeR">GitHub</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Docs page layout -->
    <div class="bs-docs-header" id="content">
        <div class="container">
        <h1>DiagrammeR Docs</h1>
        <p>Get an overview of DiagrammeR, learn the syntax, check out some examples.</p>
        </div>
    </div>
    <div class="container bs-docs-container">
        <div class="row">
            <div class="col-md-9" role="main">
                <div class="bs-docs-section">
                    <h1 id="building-graphs" class="page-header">Building Graphs</h1>
                    <p class="lead"><strong>DiagrammeR</strong> has a nice set of functions for building graphs. You can continually build the graph object, modify its attributes, get information from it, and render a graph diagram. </p>
                    <h2 id="the-graph-object">The Graph Object</h2>
                    <p>The <strong>DiagrammeR</strong> graph object, created by using the function <code>create_graph</code>, holds information on a graph's nodes, edges, default attributes, and rendering code. Creating a graph object can be as simple as using <code>create_graph()</code>, however, that will be an empty graph and you'll want to populate it.</p>
                    <p>The <strong>DiagrammeR</strong> graph object holds buckets of data that reflect the current state of the graph. The graph can be inspected, nodes and edges can be added, edited, or removed, and, a visualization of the graph or export of its data can be made at any point. The different facets of what make up the graph object can be visualized as follows.</p>
                    <div>
                        <img src="img/graph-functions/graph_object.png" class="img-responsive center-block">
                    </div>
                    <div>
                        <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                    </div>
                    <p>Essentially, the elements that make up a graph are tightly coupled inside the graph object. The myriad functions developed for working with the graph object:</p>
                    <ul>
                        <li>preserve the integrity of the data</li>
                        <li>allow for graph migrations from state to state</li>
                        <li>provide an easy-to-use interface for working with graph data</li>
                    </ul>
                    <div>
                        <img src="img/graph-functions/node_edge_data_frames_2x.png" class="img-responsive center-block">
                    </div>
                    <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                    </div>
                    <p>Getting data into a graph object is made easier through the use of specialized data frames for that contain either node data and attributes and those data frames that contain edge data and edge attributes. These data frames are especially helpful when moving data from external sources into a graph. This is because these data frames are permitted to have columns of arbitrary data alongside columns named for node or edge attributes. Having columns of data available on a per-node or per-edge basis allows for easy numerical scaling of attributes and thus a highly visual means to differentiate nodes and edges by size, color, shape, opacity, length, etc.</p>
                </div>
                <div class="bs-docs-section">
                    <h1 id="graph-functions" class="page-header">Graph Functions</h1>
                    <p class="lead">If you're planning on creating graph diagrams and also making use of external datasets, you can make use a set of <strong>DiagrammeR</strong> functions that work well with data frames. Data and attributes can be collected in this way, provided to a graph object, and then inspected, manipulated, and displayed.</p>
                    <h2 id="node-edge-data-frames">Node/Edge Data Frames</h2>
                    <p>These functions are used to create specialized data frames. One type is for nodes, the other for edges. Both types of data frames are parsed and those column names that match attributes for either nodes (in the node data frame) or edges (in the edge data frame) will be used to provide attribute values on a per-node or per-edge basis. Columns with names that don't match reserved attribute names are disregarded and, because of this, you can include columns with useful data for analysis.</p>
                        <div>
                            <img src="img/graph-functions/header_node_edge_df_processing_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/create_nodes_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/combine_nodes_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/create_edges_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/combine_edges_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/scale_nodes_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/scale_edges_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                    <p>When creating a data frame for nodes, it's important to have at least one column named either <code>node</code>, <code>nodes</code>, or <code>node_id</code>. That's where unique values for the node ID should reside. As for other attribute columns, here are all of the node attribute names and the types of values to supply:</p>
                    <ul>
                            <li><code>color</code> &mdash; provide an <strong>X11</strong> or hexadecimal color (append 2 digits to hex for alpha)</li>
                            <li><code>distortion</code> &mdash; the node distortion for any <code>shape = polygon</code></li>
                            <li><code>fillcolor</code> &mdash; provide an <strong>X11</strong> or hexadecimal color (append 2 digits to hex for alpha)</li>
                            <li><code>fixedsize</code> &mdash; <code>true</code> or <code>false</code></li>
                            <li><code>fontcolor</code> &mdash; provide an <strong>X11</strong> or hexadecimal color (append 2 digits to hex for alpha)</li>
                            <li><code>fontname</code> &mdash; the name of the font</li>
                            <li><code>fontsize</code> &mdash; the size of the font for the node label</li>
                            <li><code>height</code> &mdash; the height of the node</li>
                            <li><code>label</code> &mdash; the node label text that replaces the default text (which is the node ID)</li>
                            <li><code>penwidth</code> &mdash; the thickness of the stroke for the shape</li>
                            <li><code>peripheries</code> &mdash; the number of peripheries (essentially, additional shape outlines)</li>
                            <li><code>shape</code> &mdash; the node shape (e.g., <code>ellipse</code>, <code>polygon</code>, <code>circle</code>, etc.)</li>
                            <li><code>sides</code> &mdash; if <code>shape = polygon</code>, the number of sides can be provided here</li>
                            <li><code>style</code> &mdash; usually given the value filled if you'd like to fill a node with a color</li>
                            <li><code>tooltip</code> &mdash; provide text here for an unstyled browser tooltip</li>
                            <li><code>width</code> &mdash; the width of the node</li>
                            <li><code>x</code> &mdash; the x position of the node (requires graph attr <code>layout = neato</code> to use)</li>
                            <li><code>y</code> &mdash; the y position of the node (requires graph attr <code>layout = neato</code> to use)</li>
                        </ul>
                    <p>While you can use the <code>data.frame</code> function to make a node data frame, it is likely better to use the provided <code>create_nodes</code> function. It's similar in principle to the base <strong>R</strong> <code>data.frame</code> function except that it adds in the following conveniences for graph diagram work:
                        <ul>
                            <li>single values are repeated for n number of nodes supplied</li>
                            <li>selective setting of attributes (e.g., giving attr values for 3 of 10 nodes, allowing non-set nodes to use defaults or globally set attr values)</li>
                            <li>supplying overlong vectors for attributes will result in trimming down to the number of nodes</li>
                            <li>setting <code>label = FALSE</code> will conveniently result in a non-labeled node</li>
                        </ul>
                    <p>There may be occasion to combine several of these data frames into a single node data frame. This can be done with the <code>combine_nodes</code> function (which works much like <code>rbind</code> except that it accepts data frames with columns differing in number, names, and ordering).</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)

###
# Create two data frames for nodes
# Singly supplied attribute values are repeated down
###

nodes_1 &lt;-
  create_nodes(nodes = c("a", "b", "c", "d"),
               label = FALSE,
               type = "lower",
               style = "filled",
               color = "aqua",
               shape = c("circle", "circle",
                         "rectangle", "rectangle"),
               data = c(3.5, 2.6, 9.4, 2.7))

nodes_1
#>   nodes label  type  style color     shape data
#> 1     a       lower filled  aqua    circle  3.5
#> 2     b       lower filled  aqua    circle  2.6
#> 3     c       lower filled  aqua rectangle  9.4
#> 4     d       lower filled  aqua rectangle  2.7

nodes_2 &lt;-
  create_nodes(nodes = c("e", "f", "g", "h"),
               label = FALSE,
               type = "upper",
               style = "filled",
               color = "red",
               shape = "triangle",
               data = c(0.5, 3.9, 3.7, 8.2))

nodes_2
#>   nodes label  type  style color    shape data
#> 1     e       upper filled   red triangle  0.5
#> 2     f       upper filled   red triangle  3.9
#> 3     g       upper filled   red triangle  3.7
#> 4     h       upper filled   red triangle  8.1

###
# Combine two data frames for nodes
###

all_nodes &lt;- combine_nodes(nodes_1, nodes_2)

all_nodes
#>   nodes label  type  style color     shape data
#> 1     a       lower filled  aqua    circle  3.5
#> 2     b       lower filled  aqua    circle  2.6
#> 3     c       lower filled  aqua rectangle  9.4
#> 4     d       lower filled  aqua rectangle  2.7
#> 5     e       upper filled   red  triangle  0.5
#> 6     f       upper filled   red  triangle  3.9
#> 7     g       upper filled   red  triangle  3.7
#> 8     h       upper filled   red  triangle  8.2
</code></pre>
                        </div>
                    </div>
                    <p>When making a data frame for edge data, there are two columns that need to be present: one for the outgoing node edge, and, another for the incoming node edge. These can be called either <code>edge_from</code>, <code>from</code>, <code>edge_to</code>, or <code>to</code>. Each of the two columns should contain node IDs. Ideally, they should include only those node IDs provided in the node data frame before they both of those data frames are supplied to the <code>create_graph</code> function.</p>
                    <p>As in the nodes data frame, attributes can be provided for edges. The following edge attributes can be used:</p>
                        <ul>
                            <li><code>arrowhead</code> &mdash; the arrow style at the head end (e.g, <code>normal</code>, <code>dot</code>)</li>
                            <li><code>arrowsize</code> &mdash; the scaling factor for the arrowhead and arrowtail</li>
                            <li><code>arrowtail</code> &mdash; the arrow style at the tail end (e.g, <code>normal</code>, <code>dot</code>)</li>
                            <li><code>color</code> &mdash; the stroke color; an <strong>X11</strong> color or a hex code (add 2 digits for alpha)</li>
                            <li><code>dir</code> &mdash; the direction; either <code>forward</code>, <code>back</code>, <code>both</code>, or <code>none</code></li>
                            <li><code>fontcolor</code> &mdash; choose an <strong>X11</strong> color or provide a hex code (append 2 digits for alpha)</li>
                            <li><code>fontname</code> &mdash; the name of the font</li>
                            <li><code>fontsize</code> &mdash; the size of the font for the node label</li>
                            <li><code>headport</code> &mdash; a cardinal direction for where the arrowhead meets the node</li>
                            <li><code>label</code> &mdash; label text for the line between nodes</li>
                            <li><code>minlen</code> &mdash; minimum rank distance between head and tail</li>
                            <li><code>penwidth</code> &mdash; the thickness of the stroke for the arrow</li>
                            <li><code>tailport</code> &mdash; a cardinal direction for where the tail is emitted from the node</li>
                            <li><code>tooltip</code> &mdash; provide text here for an edge tooltip</li>
                        </ul>
                    <p>Use the <code>create_edges</code> function to create data frames for edges and their attributes. Data frames for edge definitions and their associated attributes can then be safely combined using the <code>combine_edges</code> function.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)

###
# Create two data frames for nodes
# Singly supplied attribute values are repeated down
###

edges_1 &lt;-
  create_edges(edge_from = c("a", "a", "b", "c"),
               edge_to = c("b", "d", "d", "a"),
               relationship = "requires",
               color = "green",
               data = c(2.7, 8.9, 2.6, 0.6))

edges_1
#>   edge_from edge_to relationship color data
#> 1         a       b     requires green  2.7
#> 2         a       d     requires green  8.9
#> 3         b       d     requires green  2.6
#> 4         c       a     requires green  0.6

edges_2 &lt;-
  create_edges(edge_from = c("e", "g", "h", "h"),
               edge_to = c("g", "h", "f", "e"),
               relationship = "receives",
               arrowhead = "dot",
               color = "red")

edges_2
#>   edge_from edge_to relationship arrowhead color
#> 1         e       g     receives       dot   red
#> 2         g       h     receives       dot   red
#> 3         h       f     receives       dot   red
#> 4         h       e     receives       dot   red

###
# Combine two data frames for edges
###

all_edges &lt;- combine_edges(edges_1, edges_2)

all_edges
#>   edge_from edge_to relationship color data arrowhead
#> 1         a       b     requires green  2.7
#> 2         a       d     requires green  8.9
#> 3         b       d     requires green  2.6
#> 4         c       a     requires green  0.6
#> 5         e       g     receives   red            dot
#> 6         g       h     receives   red            dot
#> 7         h       f     receives   red            dot
#> 8         h       e     receives   red            dot
</code></pre>
                        </div>
                    </div>
                    <p>With the <code>scale_nodes</code> function, it's possible to create node attributes with values that are scaled to numerical data in another column. The scaled attribute values can consist of either numerical values or hexadecimal color values. Scaled values can be made for the following attributes:</p>
                        <ul>
                            <li><code>fontsize</code> <em>numeric</em></em></li>
                            <li><code>labelfontsize</code> <em>numeric</em></li>
                            <li><code>penwidth</code> <em>numeric</em></li>
                            <li><code>height</code> <em>numeric</em></li>
                            <li><code>weight</code> <em>numeric</em></li>
                            <li><code>x</code> <em>numeric</em></li>
                            <li><code>y</code> <em>numeric</em></li>
                            <li><code>color</code> <em>color</em></li>
                            <li><code>fillcolor</code> <em>color</em></li>
                            <li><code>fontcolor</code> <em>color</em></li>
                            <li><code>alpha</code> <em>color</em></li>
                        </ul>
                    <p>For edges, the <code>scale_edges</code> function can be used to create scaled values for the following edge attributes:</p>
                        <ul>
                            <li><code>fontsize</code> <em>numeric</em></li>
                            <li><code>labelfontsize</code> <em>numeric</em></li>
                            <li><code>labelangle</code> <em>numeric</em></li>
                            <li><code>labeldistance</code> <em>numeric</em></li>
                            <li><code>penwidth</code> <em>numeric</em></li>
                            <li><code>arrowsize</code> <em>numeric</em></li>
                            <li><code>minlen</code> <em>numeric</em></li>
                            <li><code>weight</code> <em>numeric</em></li>
                            <li><code>color</code> <em>color</em></li>
                            <li><code>fontcolor</code> <em>color</em></li>
                            <li><code>labelfontcolor</code> <em>color</em></li>
                            <li><code>alpha</code> <em>color</em></li>
                        </ul>
                    <p>There is also another attribute for both nodes and edges called <code>alpha</code> which is a numeric value from <code>0</code>-<code>100</code> that modifies the opacity of a specified color attribute. A value of <code>0</code> is essentially invisible (i.e., completely transparent) whereas <code>100</code> is entirely opaque (i.e., no transparency applied). Creating an alpha scale can be done by either referencing a column containing color attribute values, or, by initializing a color attribute column and then creating an alpha scale at the same time.</p>
                    <p>Examples will be useful here. You can create a scale for the node and edge attribute <code>penwidth</code> (which changes the stroke thickness of the node shape or of the arrow). Using the data in the <code>data</code> attribute, those values will be scaled linearly from <code>2</code> to <code>5</code> for nodes and <code>1</code> to <code>5</code> for edges.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)

###
# Create a data frame for nodes
# Add an attribute which has values scaled to data
# in a column
###

set.seed(24)

nodes &lt;- create_nodes(nodes = 1:5,
                      label = FALSE,
                      type = "example",
                      data = sample(seq(1:20), 5))

nodes
#>   nodes label    type data
#> 1     1       example    6
#> 2     2       example    5
#> 3     3       example   13
#> 4     4       example    9
#> 5     5       example   11

# Use the 'scale_nodes' function to create an attribute
# column that's scaled to data in another column
nodes &lt;- scale_nodes(nodes_df = nodes,
                     to_scale = nodes$data,
                     node_attr = "penwidth",
                     range = c(2, 5))

nodes
#>   nodes label    type data penwidth
#> 1     1       example    6    2.375
#> 2     2       example    5    2.000
#> 3     3       example   13    5.000
#> 4     4       example    9    3.500
#> 5     5       example   11    4.250

###
# Create a data frames for edges
# Add an attribute which has values scaled to data
# in a column
###

set.seed(24)

edges &lt;- create_edges(edge_from = c("a", "b", "c"),
                      edge_to = c("d", "d", "a"),
                      label = '',
                      relationship = "given_to",
                      data = sample(seq(1:50), 10))

edges
#>   edge_from edge_to label relationship data
#> 1         a       d           given_to   15
#> 2         b       d           given_to   12
#> 3         c       a           given_to   34

# Use the 'scale_edges' function to create an attribute
# column that's scaled to data in another column
edges &lt;- scale_edges(edges_df = edges,
                     to_scale = edges$data,
                     edge_attr = "penwidth",
                     range = c(1, 5))

edges
#>   edge_from edge_to label relationship data penwidth
#> 1         a       d           given_to   15 1.545455
#> 2         b       d           given_to   12 1.000000
#> 3         c       a           given_to   34 5.000000</code></pre>
                        </div>
                    </div>
                    <p>To apply transparency to color values, use the <code>alpha</code> node attribute but reference the <code>color</code> attribute that should be modified with the syntax: 'alpha:[color_attr]'. If the referenced color attribute doesn't exist, use the following syntax: 'alpha:[color_attr]=[color]'. The color value can either be an <strong>X11</strong> color name or a hexadecimal color value.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">nodes &lt;- scale_nodes(nodes_df = nodes,
                          to_scale = nodes$random_data,
                          node_attr = "alpha:fillcolor",
                          range = c(5, 90))

nodes
#>    node random_data alpha_fillcolor
#> 1    85        2928       54.831206
#> 2   158        3806       70.193495
#> 3   191        4194       76.982297
#> 4   371        3757       69.336147
#> 5    58        1434       28.690819</code></pre>
                        </div>
                    </div>
                    <p>You can linearly scale color values as well. When creating color scales, ensure that the <strong>V8</strong> library is installed and loaded.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint"># install.packages("V8")
library("V8")

many_edges &lt;- scale_edges(edges_df = many_edges,
                             to_scale = many_edges$penwidth,
                             edge_attr = "color",
                             range = c("red", "green"))

create_graph(nodes_df = many_nodes, edges_df = many_edges,
               node_attrs = "style = filled",
               graph_attrs = c("layout = twopi",
                               "overlap = false")) %>>% render_graph</code></pre>
                        </div>
                    </div>
                    <h2 id="create-render-graph">Create and Render Graph</h2>
                    <p>Eventually, you'll want to make a graph and then see that graph. Two functions make that possible.</p>
                        <div>
                            <img src="img/graph-functions/header_graph_object_creation_and_rendering_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/create_graph_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/render_graph_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/display_graph_object_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                    <p>With the <code>create_graph</code> function, it's possible to generate a graph diagram object without interacting directly with <strong>DOT</strong> code. The function has the following options:</p>
<div>
<pre><code>create_graph(
    nodes_df,     # provide the name of the data frame with node info
    edges_df,     # provide the name of the data frame with edge info
    graph_attrs,  # provide a vector of 'graph' attributes
    node_attrs,   # provide a vector of 'node' attributes as defaults
    edge_attrs,   # provide a vector of 'edge' attributes as defaults
    directed      # is the graph to be directed or undirected? Choose TRUE or FALSE
    )
</code></pre>
                    </div>
                    <p>The <code>create_graph</code> function returns a <code>gv_graph</code> object, which can be used by additional processing functions.</p>
                    <p>The <code>render_graph</code> function allows for both visualizing the graph object and creating output files:</p>
                    <div>
<pre><code>render_graph(
    graph,   # a 'gv_graph' object, created using the 'create_graph' function
    output,  # a string specifying the output type; 'graph' (the default) renders
             # the graph, 'DOT' outputs DOT code for the graph, and 'SVG' provides
             # SVG code for the rendered graph
    width,   # optionally set a width in pixels
    height   # optionally set a height in pixels
    )
</code></pre>
                    </div>
                    <p>There may be cases where node or edge attributes should apply to all nodes and edges in the graph. In such cases, there's no need to create columns for those attributes where attribute values are repeated in all rows. Instead, supply vectors of attribute statements for the <code>node_attrs</code> or <code>edge_attrs</code> arguments in the <code>create_graph</code> function.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)

###
# Create an empty graph
###

graph &lt;- create_graph()

graph
#> $nodes_df
#> NULL
#>
#> $edges_df
#> NULL
#>
#> $graph_attrs
#> NULL
#>
#> $node_attrs
#> NULL
#>
#> $edge_attrs
#> NULL
#>
#> $directed
#> [1] TRUE
#>
#> $dot_code
#> [1] "digraph {\n\n}"
#>
#> attr(,"class")
#> [1] "gv_graph"

###
# Create a graph with nodes but no edges
###

nodes &lt;-
  create_nodes(nodes = c("a", "b", "c", "d"),
               label = FALSE,
               type = "lower",
               style = "filled",
               color = "aqua",
               shape = c("circle", "circle",
                         "rectangle", "rectangle"),
               data = c(3.5, 2.6, 9.4, 2.7))

graph &lt;- create_graph(nodes_df = nodes)

graph
#> $nodes_df
#>   nodes label  type  style color     shape data
#> 1     a       lower filled  aqua    circle  3.5
#> 2     b       lower filled  aqua    circle  2.6
#> 3     c       lower filled  aqua rectangle  9.4
#> 4     d       lower filled  aqua rectangle  2.7
#>
#> $edges_df
#> NULL
#>
#> $graph_attrs
#> NULL
#>
#> $node_attrs
#> NULL
#>
#> $edge_attrs
#> NULL
#>
#> $directed
#> [1] TRUE
#>
#> $dot_code
#> [1] "digraph {\n\n  'a' [label = ' ', style = 'filled',...
#>
#> attr(,"class")
#> [1] "gv_graph"

###
# Create a graph with both nodes and nodes
# defined, and, add some default attributes
###

graph &lt;-
  create_graph(nodes_df = nodes,
               edges_df = edges,
               graph_attrs = "rankdir = LR",
               node_attrs = "fontname = Helvetica",
               edge_attrs = c("color = blue",
                              "arrowsize = 2"))

graph
#> $nodes_df
#>   nodes label  type  style color     shape data
#> 1     a       lower filled  aqua    circle  3.5
#> 2     b       lower filled  aqua    circle  2.6
#> 3     c       lower filled  aqua rectangle  9.4
#> 4     d       lower filled  aqua rectangle  2.7
#>
#> $edges_df
#>   edge_from edge_to relationship
#> 1         a       d   leading_to
#> 2         b       c   leading_to
#> 3         c       a   leading_to
#>
#> $graph_attrs
#> [1] "rankdir = LR"
#>
#> $node_attrs
#> [1] "fontname = Helvetica"
#>
#> $edge_attrs
#> [1] "color = blue"  "arrowsize = 2"
#>
#> $directed
#> [1] TRUE
#>
#> $dot_code
#> [1] "digraph {\n\ngraph [rankdir = LR]\n\nnode [fontnam...
#>
#> attr(,"class")
#> [1] "gv_graph"</code></pre>
                        </div>
                    </div>
                    <p>The graph attributes can be set in a similar manner by supplying a vector to the <code>graph_attrs</code> argument. In the next rendering, the layout engine is set to <code>circo</code>, node overlapping is suppressed, the separation between nodes is of factor <code>3</code>, and the edges are drawn first (so as to not obscure the nodes).</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)

###
# Create a graph
###

nodes &lt;-
  create_nodes(nodes = LETTERS,
               type = "letter",
               shape = sample(c("circle", "rectangle"),
                              length(LETTERS),
                              replace = TRUE),
               fillcolor = sample(c("aqua", "gray80",
                                    "pink", "lightgreen",
                                    "azure", "yellow"),
                                  length(LETTERS),
                                  replace = TRUE))

edges &lt;-
  create_edges(edge_from = sample(LETTERS, replace = TRUE),
               edge_to = sample(LETTERS, replace = TRUE),
               relationship = "letter_to_letter")


graph &lt;-
  create_graph(nodes_df = nodes,
               edges_df = edges,
               graph_attrs = "layout = neato",
               node_attrs = c("fontname = Helvetica",
                              "style = filled"),
               edge_attrs = c("color = gray20",
                              "arrowsize = 0.5"))

# View the graph in the RStudio Viewer
render_graph(graph)</code></pre>
                        </div>
                    </div>
                    <p>For a visual summary of the graph, use the <code>display_graph_object</code> function.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint"># View a visual summary of the graph in the RStudio Viewer
display_graph_object(graph)</code></pre>
                        </div>
                    </div>
                    <p>With packages such as <strong>magrittr</strong> or <strong>pipeR</strong>, one can conveniently pipe output from <code>create_graph</code> to <code>render_graph</code>. The <strong>pipeR</strong> package provides a forward pipe with the <code>%>>%</code> operator. With <strong>magrittr</strong>, use <code>%>%</code> instead.</p>
                    <p>If you'd like to return the <strong>Graphviz</strong> <strong>DOT</strong> code (to, perhaps, share it or use it directly with the <strong>Graphviz</strong> command-line utility), just use <code>output = "DOT"</code> in the <code>render_graph</code> function. Here's a simple example:</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)
library(pipeR)
library(V8)

###
# Create nodes and edges data frames for graph
###

nodes &lt;-
  create_nodes(nodes = LETTERS,
               type = "letter",
               shape = sample(c("circle", "rectangle"),
                              length(LETTERS),
                              replace = TRUE),
               fillcolor = sample(c("aqua", "gray80",
                                    "pink", "lightgreen",
                                    "azure", "yellow"),
                                  length(LETTERS),
                                  replace = TRUE))

edges &lt;-
  create_edges(edge_from = sample(LETTERS, replace = TRUE),
               edge_to = sample(LETTERS, replace = TRUE),
               relationship = "letter_to_letter")

# Use pipeR %>>% operator between 'create_graph',
# and 'render_graph' or 'display_graph_object' calls
create_graph(nodes_df = nodes,
             edges_df = edges,
             graph_attrs = "layout = neato",
             node_attrs = c("fontname = Helvetica",
                            "style = filled"),
             edge_attrs = c("color = gray20",
                            "arrowsize = 0.5")) %>>%
  render_graph

create_graph(nodes_df = nodes,
             edges_df = edges,
             graph_attrs = "layout = neato",
             node_attrs = c("fontname = Helvetica",
                            "style = filled"),
             edge_attrs = c("color = gray20",
                            "arrowsize = 0.5")) %>>%
  display_graph_object

# Use pipeR %>>% operator between 'create_graph',
# 'render_graph', and 'cat' calls; the 'dot.gv' can be
# directly opened in Rstudio and further edited
create_graph(nodes_df = nodes,
             edges_df = edges,
             graph_attrs = "layout = neato",
             node_attrs = c("fontname = Helvetica",
                            "style = filled"),
             edge_attrs = c("color = gray20",
                            "arrowsize = 0.5")) %>>%
  render_graph(output = "DOT") %>>% cat(file = "~/dot.gv")

# To generate an SVG file, use 'output = "SVG"'
create_graph(nodes_df = nodes,
             edges_df = edges,
             graph_attrs = "layout = neato",
             node_attrs = c("fontname = Helvetica",
                            "style = filled"),
             edge_attrs = c("color = gray20",
                            "arrowsize = 0.5")) %>>%
  render_graph(output = "SVG") %>>% cat(file = "~/graph.svg")

# Very large graphs are possible to make but rendering
# to the RStudio Viewer is not advisable; better to export
# as DOT or SVG, view a visual summary, or use graph
# inspection functions
create_graph(nodes_df =
               create_nodes(node = sample(1:90000, 90000)),
             edges_df =
               create_edges(from = sample(1:90000, 90000),
                            to = sample(1:90000, 90000))) %>>%
  display_graph_object</code></pre>
                        </div>
                    </div>
                    <h2 id="inspecting-the-graph">Inspecting the Graph</h2>
                    <p>Knowing what's in the graph is important. Several functions allow you to get information about the current state of the graph object. You can get very general information about the graph's node or edges, or, more specific information such as the predecessors and successors for a certain node in the graph</p>
                        <div>
                            <img src="img/graph-functions/header_graph_inspection_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/is_graph_empty_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/node_info_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/edge_info_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/node_present_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/edge_present_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/get_nodes_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/get_edges_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/get_predecessors_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/get_sucessors_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/node_count_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                    <p>The <code>is_graph_empty</code> and <code>is_directed</code> functions simply return either <code>TRUE</code> or <code>FALSE</code> on whether the graph is empty and whether the graph is a directed graph. These are likely to be most useful in verification statement for scripts that add and remove nodes from the graph, or, those scripts that toggle the graph between directed and undirected states. The <code>node_info</code> and <code>edge_info</code> provide information about the nodes and edges in the graph. The information is presented in the form of a data frame. For <code>node_info</code>, the following data is returned:</p>
                        <ul>
                            <li>node</li>
                            <li>label</li>
                            <li>type</li>
                            <li>degree</li>
                            <li>indegree</li>
                            <li>outdegree</li>
                            <li>loops</li>
                        </ul>
                    <p>From the <code>edge_info</code> function, the resultant data frame has the following columns:</p>
                        <ul>
                            <li>edge_from</li>
                            <li>edge_to</li>
                            <li>relationship</li>
                            <li>label</li>
                        </ul>
                    <p>All the aforementioned functions take only a graph object when called.</p>
                    <p>The <code>node_present</code> and <code>edge_present</code> functions are used to determine whether a node (based on its node ID) or an edge (based on two node IDs) is present in a graph object. Both functions return a logical value of either <code>TRUE</code> or <code>FALSE</code>.</p>
                    <p>The purpose of the <code>get_nodes</code> and <code>get_edges</code> functions is to return either all of the nodes or edges (i.e., pairs of nodes, ordered by direction) available in the graph, or, in data frames for nodes or edges. For <code>get_nodes</code>, one can simply supply either a graph object, a data frame for nodes, or a data frame for edges, and a vector of node IDs will be returned. For the <code>get_edges</code> function, there is an additional argument called <code>return_type</code>, where you can specify three different types of return objects: a list with <code>return_type = list</code>, a data frame with <code>return_type = df</code>, and a character vector with <code>return_type = vector</code>. Whereas <code>get_nodes</code> works with graph objects and data frames for nodes and edges, <code>get_edges</code> works only with graph objects and data frames for node data.</p>
                    <p>The <code>get_predecessors</code> and <code>get_successors</code> function take both a graph object and a specified node in that graph and determine which nodes are its predecessors or successors, respectively.</p>
                    <p>To get a count of all or certain types of nodes available in the graph, you can use the <code>node_count</code> function. The argument <code>type</code> can either be supplied with a <code>TRUE</code> or <code>FALSE</code> value, or, a character vector containing the values for the node type which may be available for nodes in the graph. Providing <code>TRUE</code> will issue a named vector of node counts by their type. Any nodes with a <code>type</code> attribute not set with a value are placed into a separate count category. Using <code>type = FALSE</code> with <code>node_count</code> simply supplied a single-value vector with a total count of nodes in the graph. By providing a vector of character values of available node <code>type</code> values, a numerical named vector of counts for only those specified types will be returned.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)
library(pipeR)

###
# Create a graph
###

set.seed(26)

nodes &lt;-
  create_nodes(nodes = LETTERS,
               label = TRUE,
               type = c(rep("a_to_g", 7),
                        rep("h_to_p", 9),
                        rep("q_to_x", 8),
                        rep("y_and_z",2)))

edges &lt;-
  create_edges(edge_from = sample(LETTERS, replace = TRUE),
               edge_to = sample(LETTERS, replace = TRUE),
               label = "edge",
               relationship = "letter_to_letter")

graph &lt;- create_graph(nodes_df = nodes,
                      edges_df = edges,
                      graph_attrs = "layout = neato",
                      node_attrs = c("fontname = Helvetica",
                                     "shape = circle"))

###
# Is the graph empty?
###

is_graph_empty(graph)
#> FALSE

###
# Get basic information on the graph's nodes and edges
###

node_info(graph)
#>    node_ID label    type degree indegree outdegree loops
#> 1        A     A  a_to_g      2        0         2     0
#> 2        W     W  q_to_x      1        0         1     0
#> 3        T     T  q_to_x      2        0         2     0
#> 4        L     L  h_to_p      1        0         1     0
#> 5        F     F  a_to_g      0        0         0     0
#>..      ...   ...     ...    ...      ...       ...   ...

edge_info(graph)
#>    edge_from edge_to     relationship label
#> 1          A       Z letter_to_letter  edge
#> 2          H       U letter_to_letter  edge
#> 3          W       O letter_to_letter  edge
#> 4          U       K letter_to_letter  edge
#> 5          I       V letter_to_letter  edge
#>..        ...     ...              ...   ...

###
# Find out if a node is present in the graph
###

# Verify that node with ID 'a' is not in graph
node_present(graph, "a")
#> FALSE

# Is node with ID 'A' in the graph?
node_present(graph, "A")
#> TRUE

# Are all node ID values from the LETTERS vector in the graph?
all(sapply(LETTERS, function(x) node_present(graph, x)))
#> TRUE

###
# Find out if an edge is present in the graph
###

# Is there any edge between nodes with IDs 'A' and 'B'?
edge_present(graph, from = "A", to = "B")
#> FALSE

# Verify that there is an edge between nodes 'K' and 'V'
edge_present(graph, from = "K", to = "V")
#> TRUE

###
# Get vector of all nodes in a graph, or in data frames
# for nodes or edges
###

get_nodes(graph)
#> [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L"
#> [13] "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X"
#> [25] "Y" "Z"

# Can extract a vector of node ID values from a data frame
# for nodes
table(get_nodes(nodes) %in% get_nodes(graph))
#>
#> TRUE
#>   26

# Can also extract a vector of node ID values from a
# data frame for edges
table(get_nodes(graph) %in% get_nodes(edges))
#>
#> FALSE  TRUE
#>     3    23

###
# Get object with all edges in a graph, or in a data
# frame for edges
###

# Can get the 'outgoing' and 'incoming' node ID values
# in a list object
get_edges(graph, return_type = "list") # the default
#> [[1]]
#>  [1] "A" "H" "W" "U" "I" "M" "U" "T" "I" "R" "O"
#> [12] "G" "O" "A" "V" "I" "M" "K" "R" "T" "Y" "R"
#> [23] "M" "L" "H" "V"

#> [[2]]
#>  [1] "Z" "U" "O" "K" "V" "M" "N" "C" "D" "Z" "B"
#> [12] "G" "U" "Y" "H" "V" "R" "V" "Z" "S" "Q" "I"
#> [23] "P" "S" "E" "P"

# Similarly, you can specify that a data frame is given
get_edges(graph, return_type = "df")
#>    from to
#> 1     A  Z
#> 2     H  U
#> 3     W  O
#> 4     U  K
#> 5     I  V
#>..   ... ..

# A character string with node IDs can instead be gotten
get_edges(graph, return_type = "vector")
#>  [1] "A -> Z" "H -> U" "W -> O" "U -> K" "I -> V"
#>  [6] "M -> M" "U -> N" "T -> C" "I -> D" "R -> Z"
#> [11] "O -> B" "G -> G" "O -> U" "A -> Y" "V -> H"
#> [16] "I -> V" "M -> R" "K -> V" "R -> Z" "T -> S"
#> [21] "Y -> Q" "R -> I" "M -> P" "L -> S" "H -> E"
#> [26] "V -> P"

###
# As with 'get_nodes', the 'get_edges' function works
# in an analogous manner with data frames for edges
###

all(get_edges(edges, return_type = "list")[[1]] ==
      get_edges(graph, return_type = "list")[[1]])
#> TRUE

all(get_edges(edges, return_type = "df") ==
      get_edges(graph, return_type = "df"))
#> TRUE

all(get_edges(edges, return_type = "vector") ==
      get_edges(graph, return_type = "vector"))
#> TRUE

###
# Get all the predecessors or all of the successors
# of a given node
###

render_graph(graph)

# If there are no predecessors, NA is returned
get_predecessors(graph, node = "A")
#> [1] NA

get_successors(graph, node = "A")
#> [1] "Z" "Y"

get_successors(graph, node = "Z")
#> [1] NA

get_predecessors(graph, node = "Z")
#> [1] "A" "R" "R"

# Find isolated nodes in a graph (they have neither successors
# nor predecessors)
intersect(
  names(which(is.na(sapply(get_nodes(graph),
                           function(x) get_successors(graph, x))))),
  names(which(is.na(sapply(get_nodes(graph),
                           function(x) get_predecessors(graph, x)))))
)
#> [1] "F" "J" "X"

# The isolated nodes can also be found by subsetting 'node_info'
node_info(graph)[which(node_info(graph)["degree"] == 0), ][, 1]
#> [1] "F" "J" "X"

###
# Get a count of all nodes in a graph
###

# Get counts of nodes grouped by the "type" attribute
node_count(graph, type = TRUE) # the default
#> a_to_g  h_to_p  q_to_x y_and_z
#>      7       9       8       2

# Get a total count of nodes with no grouping
node_count(graph, type = FALSE)
#> [1] 26</code></pre>
                        </div>
                    </div>
                    <h2 id="modifying-the-graph">Modifying the Graph</h2>
                    <p>Add nodes, delete edges, modify relationships between nodes, set node type declarations... Those are some of the things you can do with these graph construction/destruction functions.</p>
                        <div>
                            <img src="img/graph-functions/header_graph_modification_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/add_node_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/add_edges_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/delete_node_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/delete_edge_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/node_type_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/edge_relationship_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                    <p>The <code>add_node</code> function allows one to add a single node to a graph. Specify the graph to which the node should be added and the node ID for the <code>node</code> argument, and a node will be added. While the other arguments are optional, using just <code>graph</code> and <code>node</code> will result in the addition of an unconnected node. This might be desirable (say, if the graph is empty), but the more likely case is that edges to other nodes will be required upon addition of a new node. The <code>from</code> and <code>to</code> arguments (both optional) are where you would specify connections from existing nodes to the new node (with <code>to</code>), and connections to existing nodes from the new node (with <code>from</code>). A vector of node IDs can be supplied to either argument. The <code>label</code> and <code>type</code> arguments allow for direct setting of these node attributes during the addition of a node. Finally, a named vector of node attributes and their values can be included in the <code>add_node</code> call.</p>
                    <p>The <code>add_edges</code> function is meant for adding edges between extant graph nodes. Because the nodes must exist in the graph, this function cannot be invoked for an empty graph. (It can, however, be used for a graph with a single node since an edge can be created as a loop from and to the same node.) there are two means to add edges to a graph with this function:</p>
                    <ol>
                      <li>specify <code>from</code> and <code>to</code> nodes for the edge to be added; add an edge <code>relationship</code> string as a value for the <code>relationship</code> argument</li>
                      <li>supply a data frame for edges, which contains columns for incoming and outgoing nodes, and, various edge attributes</li>
                    </ol>
                    <p>It can be advantageous to supply a data frame for edges to this function's <code>edges_df</code> argument. This simply because one can supply a range of edge attributes for the new edge. On the other hand, providing only values to the <code>from</code>, <code>to</code>, and <code>relationship</code> arguments may be sufficient, especially if styling if not required or handled through default edge attributes.</p>
                    <p>The function <code>delete_node</code> removes a node from the graph. All of the removed node's edges with other nodes in the graph will also be removed in this operation. Supply only a single node ID to the <code>node</code> argument.</p>
                    <p>The function <code>delete_edge</code> removes an edge from the graph. Specify the graph object in <code>graph</code>, the nodes in <code>nodes</code>, and the function will remove that edge if it exists.</p>
                    <p>The <code>node_type</code> function provides various means to check the <code>type</code> attribute for a node and perform different operations on that attribute. The different functionalities of <code>node_type</code> can be changed through the use of these different keywords for the <code>action</code> argument: <code>read</code>, <code>check</code>, <code>add</code>, <code>update</code>, and <code>delete</code>. With <code>read</code> set as the action, a node ID supplied with the graph object yields that node's <code>type</code> attribute. Using <code>action = check</code> with a node ID, you can check whether a <code>type</code> attribute exists (it will return <code>TRUE</code> or <code>FALSE</code>. If the <code>type</code> attribute hasn't been set for a node, you can add that using <code>action = add</code> along with a string supplied for the <code>value</code> argument. If a <code>type</code> attribute has alredy been set for a node and you'd like to change it, use <code>action = update</code> and include the updated string with the <code>value</code> argument. Deleting a <code>type</code> attribute for a node is easily accomplished by using <code>action = delete</code>.</p>
                    <p>The <code>edge_relationship</code> function is similar in principle and use to the <code>node_type</code> function. In this function, the edge's <code>relationship</code> attribute can be checked for existence, added, removed, or updated. As with the <code>node_type</code> function, this function uses the <code>action</code> argument and performs various actions with these keywords: <code>read</code>, <code>check</code>, <code>add</code>, <code>update</code>, and <code>delete</code> (same keywords as those for <code>node_type</code>. Using <code>read</code>, supply node IDs for the <code>from</code> and <code>to</code> arguments. With that, you will receive the edge's currently set <code>relationship</code> attribute. The <code>relationship</code> attribute may or may not be set, so, using <code>action = check</code> with a specified edge, the existence of the <code>relationship</code> attribute can be verified through a <code>TRUE</code> or <code>FALSE</code> return value. An unset <code>relationship</code> attribute for an edge can be set by using <code>action = add</code> and a character string for the <code>value</code> argument. To update an already set <code>relationship</code> attribute for an edge, use <code>action = update</code> and provide the updated relationship string with the <code>value</code> argument. Deleting a <code>relationship</code> attribute for an edge is done by using <code>action = delete</code> with an edge.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)

# Create an empty graph
graph &lt- create_graph()

# Add two nodes
graph &lt;- add_node(graph, node = "a")
graph &lt;- add_node(graph, node = "b")

# Get information on nodes in graph
node_info(graph)

#>   node_ID label type degree indegree outdegree loops
#> 1       a     a   NA      0        0         0     0
#> 2       b     b   NA      0        0         0     0

# Add an edge
graph &lt;- add_edges(graph, from = "a", to = "b",
                   relationship = "to_get")</code></pre>
                        </div>
                    </div>
                </div>
                <div class="bs-docs-section">
                    <h1 id="examples" class="page-header">Examples</h1>
                    <p class="lead">Here is a selection of examples to demonstrate how these graph functions can be used with external datasets.</p>
                    <h2 id="nycflights13">Data from nycflights13</h2>
                    <p>Let's use the <strong>nycflights13</strong> package to prepare some data frames and then create a graph diagram.</p>
                    <div class="bs-example">
                        <img src="img/grviz_example-3-1.png" class="img-responsive center-block">
                    </div>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint"># Get the 'nycflights13' package if not already installed
# install.packages('nycflights13')

# Get the 'lubridate' package if not already installed
# install.packages('lubridate')

# Get the latest build of the 'DiagrammeR' package from GitHub
devtools::install_github('rich-iannone/DiagrammeR')

library("nycflights13")
library("lubridate")
library("DiagrammeR")

# Choose a day from 2013 for NYC flight data
# (You can choose any Julian day, it's interesting to see results for different days)
day_of_year &lt;- 10

# Get a data frame of complete cases (e.g., flights have departure and arrival times)
nycflights13 &lt;-
  nycflights13::flights[which(complete.cases(nycflights13::flights) == TRUE), ]

# Generate a POSIXct vector of dates using the 'ISOdatetime' function
# Columns 1, 2, and 3 are year, month, and day columns
# Column 4 is a 4-digit combination of hours (00-23) and minutes (00-59)
date_time &lt;-
  data.frame("date_time" =
               ISOdatetime(year = nycflights13[,1],
                           month = nycflights13[,2],
                           day = nycflights13[,3],
                           hour = gsub("[0-9][0-9]$", "", nycflights13[,4]),
                           min = gsub(".*([0-9][0-9])$", "\\1", nycflights13[,4]),
                           sec = 0, tz = "GMT"))

# Add the POSIXct vector 'date_time' to the 'nycflights13' data frame
nycflights13 &lt;- cbind(date_time, nycflights13)

# Select flights only from the specified day of the year 2013
nycflights13_day &lt;-
  subset(nycflights13,
         date_time >= ymd('2013-01-01', tz = "GMT") + days(day_of_year - 1) &
           date_time &lt; ymd('2013-01-01', tz = "GMT") + days(day_of_year))

# Create the 'nodes' data frame where at least one column is named "nodes" or "node_id"
# Column 12 is the 3-letter code for the airport departing from
# Column 13 is for the airport arriving to
# (Option: change df to 'nycflights13_day' and only airports used for the day will be included)
nodes_df &lt;- create_nodes(nodes = unique(c(nycflights13[,12],
                                    nycflights13[,13])),
                         label = FALSE)

# The 'edges' data frame must have columns named 'edge_from' and 'edge_to'
# The color attribute is determined with an 'ifelse' statement, where
# column 8 is the minutes early (negative values) or minutes late (positive values)
# for the flight arrival
edges_df &lt;- create_edges(edge_from = nycflights13_day[,12],
                         edge_to = nycflights13_day[,13],
                         color = ifelse(nycflights13_day[,8] &lt; 0,
                                    "green", "red"))

# Set the graph diagram's default attributes for...

# ...nodes
node_attrs &lt;- c("style = filled", "fillcolor = lightblue",
                "color = gray", "shape = circle", "fontname = Helvetica",
                "width = 1")

# ...edges
edge_attrs &lt;- c("arrowhead = dot")

# ...and the graph itself
graph_attrs &lt;- c("layout = circo",
                 "overlap = false",
                 "fixedsize = true",
                 "ranksep = 3",
                 "outputorder = edgesfirst")

# Generate the graph diagram in the RStudio Viewer.
# The green lines show flights that weren't late (red indicates late arrivals)
# This graph is for a single day of flights, airports that are unconnected on a
# given day may be destinations on another day
create_graph(nodes_df = nodes_df, edges_df = edges_df,
             graph_attrs = graph_attrs, node_attrs = node_attrs,
             edge_attrs = edge_attrs, directed = TRUE) %>>%
               render_graph(width = 1200, height = 800)</code></pre>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-3" role="complementary">
                <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm">
                    <ul class="nav bs-docs-sidenav">
                        <li>
                            <a href="#building-graphs">Building Graphs</a>
                            <ul class="nav">
                                <li><a href="#the-graph-object">The Graph Object</a></li>
                            </ul>
                        </li>
                        <li>
                            <a href="#graph-functions">Graph Functions</a>
                            <ul class="nav">
                                <li><a href="#node-edge-data-frames">Node/Edge Data Frames</a></li>
                                <li><a href="#create-render-graph">Create and Render Graph</a></li>
                                <li><a href="#inspecting-the-graph">Inspecting the Graph</a></li>
                                <li><a href="#modifying-the-graph">Modifying the Graph</a></li>
                            </ul>
                        </li>
                        <li>
                            <a href="#examples">Examples</a>
                            <ul class="nav">
                                <li><a href="#nycflights13">Data from nycflights13</a></li>
                            </ul>
                        </li>
                    </ul>
                    <a class="back-to-top" href="#top">Back to top</a>
                </nav>
            </div>
        </div>

        <footer class="bs-docs-footer" role="contentinfo">
            <div class="container">
                <div class="bs-docs-social">
                    <ul class="bs-docs-social-buttons">
                        <li>
                            <iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=rich-iannone&amp;repo=DiagrammeR&amp;type=watch&amp;count=true" width="90" height="20" title="Star on GitHub"></iframe>
                        </li>
                        <li>
                            <iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=rich-iannone&amp;repo=DiagrammeR&amp;type=fork&amp;count=true" width="90" height="20" title="Fork on GitHub"></iframe>
                        </li>
                    </ul>
                    <ul class="bs-docs-social-buttons">
                        <li class="follow-btn">
                            <a href="https://twitter.com/riannone" class="twitter-follow-button" data-link-color="#0069D6" data-show-count="true">Follow @riannone</a>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="container">
                <p>Designed and built by Richard Iannone <a href="https://twitter.com/riannone" target="_blank">@riannone</a>.</p>
                <p>Valuable contributions by Kent Russell <a href="https://twitter.com/timelyportfolio" target="_blank">@timelyportfolio</a>, JJ Allaire <a href="https://twitter.com/rstudio" target="_blank">@rstudio</a>, and Michaël Benesty <a href="https://twitter.com/pommedeterre33" target="_blank">@pommedeterre33</a>.</p>
                <p>Code licensed under MIT.</p>
                <ul class="bs-docs-footer-links text-muted">
                    <li>Currently v0.6</li>
                    <li>&middot;</li>
                    <li><a href="https://github.com/rich-iannone/DiagrammeR">GitHub</a></li>
                    <li>&middot;</li>
                    <li><a href="https://github.com/rich-iannone/DiagrammeR/issues">Issues</a></li>
                    <li>&middot;</li>
                    <li><a href="https://github.com/rich-iannone/DiagrammeR/releases">Releases</a></li>
                </ul>
            </div>
        </footer>


        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="./js/bootstrap.min.js"></script>
        <script src="./js/docs.min.js"></script>
        <script src="./js/ie10-viewport-bug-workaround.js"></script>
        <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>

        <script>
          window.twttr = (function (d,s,id) {
            var t, js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return; js=d.createElement(s); js.id=id; js.async=1;
            js.src="https://platform.twitter.com/widgets.js"; fjs.parentNode.insertBefore(js, fjs);
            return window.twttr || (t = { _e: [], ready: function(f){ t._e.push(f) } });
          }(document, "script", "twitter-wjs"));
        </script>

    </body>
</html>
